<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kunal Aneja — Procedural Mesh Pulse (RL)</title>
  <style>
    :root{
      --bg:#0B0D10; --text:#E6EDF3; --a1:#60A5FA; --a2:#A78BFA;
    }
    html,body{height:100%; margin:0; background:var(--bg); color:var(--text); overflow-x:hidden;}
    #bg{position:fixed; inset:0; width:100%; height:100%; display:block;}
    /* Foreground content (minimal portfolio shell) */
    .wrap{position:relative; z-index:1; max-width:900px; margin:8rem auto; padding:0 24px;}
    h1{font:800 56px/1.05 system-ui,Segoe UI,Inter,Arial; margin:0 0 8px;}
    h2{font:700 22px/1.25 system-ui,Segoe UI,Inter,Arial; margin:32px 0 12px;}
    p,li{font:400 16px/1.6 system-ui,Segoe UI,Inter,Arial; opacity:.92}
    .cards{display:grid; gap:16px; grid-template-columns:repeat(auto-fit,minmax(240px,1fr))}
    .card{backdrop-filter:blur(8px); background:rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.08);
      border-radius:12px; padding:14px 16px; box-shadow:0 8px 30px rgba(0,0,0,.2)}
    a{color:var(--a1); text-decoration:none}
    a:hover{color:var(--a2)}
    /* Reduced motion → static image frame (we'll render one and freeze) */
    @media (prefers-reduced-motion: reduce) { #bg{animation:none !important} }
  </style>
</head>
<body>
  <canvas id="bg" aria-hidden="true"></canvas>

  <main class="wrap" role="main">
    <h1>Kunal Aneja</h1>
    <p>Robotics · RL · Embodied AI</p>

    <h2>Work</h2>
    <div class="cards">
      <div class="card"><strong>AMPLIFY</strong><br/><small>Actionless video dynamics + inverse dynamics</small></div>
      <div class="card"><strong>FLASH</strong><br/><small>Language-conditioned dexterous grasping (fast CFM backend)</small></div>
      <div class="card"><strong>I2G2RO</strong><br/><small>Vision policy via BC + RL in Isaac Lab</small></div>
    </div>

    <h2>Contact</h2>
    <p><a href="mailto:hello@kunalaneja.com">Email</a> · <a href="https://linkedin.com/in/kunalaneja">LinkedIn</a> · <a href="https://github.com/kunalaneja">GitHub</a></p>
  </main>

  <script type="module">
    // ===== WebGL2 "Procedural Fabric / Mesh Pulse" with tiny RL bandit =====
    const canvas = document.getElementById('bg');
    const gl = canvas.getContext('webgl2', {antialias:true, powerPreference:'high-performance'});
    if(!gl){ console.warn('WebGL2 not available'); }

    // Resize handling
    const DPR = Math.min(window.devicePixelRatio || 1, 2);
    function fit(){ 
      const w = Math.max(1, Math.floor(innerWidth * DPR));
      const h = Math.max(1, Math.floor(innerHeight * DPR));
      canvas.width = w; canvas.height = h;
      canvas.style.width = '100%'; canvas.style.height = '100%';
      gl && gl.viewport(0,0,w,h);
    }
    addEventListener('resize', fit, {passive:true}); fit();

    // Shaders
    const vert = `#version 300 es
    precision highp float;
    layout (location=0) in vec2 position;
    out vec2 v_uv;
    void main(){
      v_uv = position*0.5 + 0.5;
      gl_Position = vec4(position, 0.0, 1.0);
    }`;

    const frag = `#version 300 es
    precision highp float;
    out vec4 outColor;
    in vec2 v_uv;

    uniform vec2  u_res;
    uniform float u_time;
    uniform float u_gridScale;
    uniform float u_lineWidth;
    uniform float u_baseAmp;
    uniform float u_noiseAmp;

    uniform vec2  u_pulseCenter;
    uniform float u_pulseStart;
    uniform float u_pulseStrength;
    uniform float u_pulseSpeed;
    uniform vec3  u_lineColor;

    // Value noise + fbm (compact)
    float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453123); }
    float noise(vec2 p){
      vec2 i = floor(p), f = fract(p);
      float a = hash(i);
      float b = hash(i + vec2(1.0,0.0));
      float c = hash(i + vec2(0.0,1.0));
      float d = hash(i + vec2(1.0,1.0));
      vec2 u = f*f*(3.0-2.0*f);
      return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;
    }
    float fbm(vec2 p){
      float v=0.0, a=0.5;
      for(int i=0;i<4;i++){ v += a*noise(p); p *= 2.0; a *= 0.5; }
      return v;
    }

    // Ring-shaped pulse (smooth expanding ripple)
    float pulse(vec2 uv, float t, vec2 c, float speed){
      if(t < 0.0) return 0.0;
      float r = t * speed;
      float d = distance(uv, c);
      // gaussian ring with soft width
      float w = 0.015 + 0.01 * sin(t*1.7);
      float g = exp(-pow((d - r), 2.0) / (2.0*w*w));
      return g;
    }

    void main(){
      // Normalize to square-ish space
      vec2 uv = v_uv;
      uv.x *= u_res.x / max(u_res.x, u_res.y);
      uv.y *= u_res.y / max(u_res.x, u_res.y);

      // Base deformation: crossed sines + fbm
      float f1 = sin((uv.y*3.2) + u_time*0.8);
      float f2 = sin((uv.x*2.6) + u_time*1.05);
      float n  = fbm(uv*3.0 + u_time*0.1);
      vec2 disp = vec2(f1, f2) * u_baseAmp + (n - 0.5) * u_noiseAmp;

      // Pulse displacement along radial direction
      float tPulse = u_time - u_pulseStart;
      float ring = pulse(uv, tPulse, u_pulseCenter, u_pulseSpeed);
      vec2 dir = normalize(uv - u_pulseCenter + 1e-4);
      disp += dir * (ring * u_pulseStrength);

      // Deformed grid coordinates
      vec2 gp = (uv + disp) * u_gridScale;

      // Anti-aliased grid lines
      vec2 cell = abs(fract(gp - 0.5) - 0.5);
      float d = min(cell.x, cell.y);
      float aa = fwidth(d) + 1e-4;
      float line = 1.0 - smoothstep(u_lineWidth - aa, u_lineWidth + aa, d);

      // Slightly brighten the ring itself (highlight)
      float highlight = clamp(ring*1.5, 0.0, 1.0);

      vec3 base = vec3(0.0);
      vec3 col = mix(base, u_lineColor, line) + highlight * (u_lineColor*1.3);
      outColor = vec4(col, 1.0);
    }`;

    // Compile
    function sh(type, src){ const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s);
      if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(s); return s; }
    function prog(vs, fs){ const p = gl.createProgram(); gl.attachShader(p, vs); gl.attachShader(p, fs);
      gl.linkProgram(p); if(!gl.getProgramParameter(p, gl.LINK_STATUS)) throw gl.getProgramInfoLog(p); return p; }

    const program = prog(sh(gl.VERTEX_SHADER, vert), sh(gl.FRAGMENT_SHADER, frag));
    gl.useProgram(program);

    // Fullscreen triangle
    const quad = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, quad);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      -1,-1,  3,-1,  -1,3
    ]), gl.STATIC_DRAW);
    gl.enableVertexAttribArray(0);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

    // Uniforms
    const U = n => gl.getUniformLocation(program, n);
    const u = {
      res: U('u_res'), time: U('u_time'),
      gridScale: U('u_gridScale'), lineWidth: U('u_lineWidth'),
      baseAmp: U('u_baseAmp'), noiseAmp: U('u_noiseAmp'),
      pulseCenter: U('u_pulseCenter'), pulseStart: U('u_pulseStart'),
      pulseStrength: U('u_pulseStrength'), pulseSpeed: U('u_pulseSpeed'),
      lineColor: U('u_lineColor')
    };

    // Default params (will be tuned by the bandit)
    const P = {
      gridScale: 26.0,
      lineWidth: 0.018,
      baseAmp: 0.030,
      noiseAmp: 0.045,
      pulseStrength: 0.06,
      pulseSpeed: 0.70,
      lineColor: [0.86, 0.93, 0.98] // nearly white on dark
    };

    // ===== Tiny ε-greedy bandit to tune visual parameters (RL-lite) =====
    const arms = [
      {name:'calm',   params:{baseAmp:.022, noiseAmp:.030, pulseStrength:.05, pulseCadence:[6,11], gridScale:24}, value:0, pulls:0},
      {name:'flowy',  params:{baseAmp:.032, noiseAmp:.045, pulseStrength:.06, pulseCadence:[5,9],  gridScale:26}, value:0, pulls:0},
      {name:'spicy',  params:{baseAmp:.040, noiseAmp:.060, pulseStrength:.08, pulseCadence:[4,7],  gridScale:28}, value:0, pulls:0},
      {name:'tight',  params:{baseAmp:.026, noiseAmp:.018, pulseStrength:.05, pulseCadence:[7,12], gridScale:30}, value:0, pulls:0}
    ];
    let eps = 0.18, current = null, lastChoose = performance.now(), lastMetrics = {dist:0, hover:0, clicks:0};

    function chooseArm(){
      // decay epsilon slightly
      eps = Math.max(0.06, eps * 0.985);
      if(Math.random() < eps){
        current = arms[(Math.random()*arms.length)|0];
      }else{
        current = arms.reduce((a,b)=> (a.pulls ? a.value/a.pulls : -1) > (b.pulls ? b.value/b.pulls : -1) ? a : b);
      }
      // Apply chosen parameters
      const p = current.params;
      P.baseAmp = p.baseAmp; P.noiseAmp = p.noiseAmp; P.pulseStrength = p.pulseStrength; P.gridScale = p.gridScale;
      cadence = p.pulseCadence;
      lastChoose = performance.now();
      // reset metrics
      lastMetrics = {dist:0, hover:0, clicks:0};
    }
    chooseArm();

    // Engagement → reward
    let hover = false, hoverStart = 0;
    let lastX=0, lastY=0;
    canvas.addEventListener('pointerenter', e=>{ hover=true; hoverStart=performance.now(); lastX=e.clientX; lastY=e.clientY; }, {passive:true});
    canvas.addEventListener('pointerleave', ()=>{ hover=false; }, {passive:true});
    canvas.addEventListener('pointermove', e=>{
      if(!hover) return;
      lastMetrics.dist += Math.hypot(e.clientX-lastX, e.clientY-lastY);
      lastX=e.clientX; lastY=e.clientY;
    }, {passive:true});
    canvas.addEventListener('click', ()=>{ lastMetrics.clicks += 1; }, {passive:true});

    setInterval(()=>{
      const now = performance.now();
      const dt = (now - lastChoose)/1000; // seconds since choose
      if(hover) lastMetrics.hover += dt;
      // reward: scaled movement + clicks + dwell; normalize by time window
      const reward = (lastMetrics.dist/600 + lastMetrics.clicks*2.0 + lastMetrics.hover*0.6) / Math.max(1, dt);
      current.value += reward; current.pulls += 1;
      chooseArm();
    }, 6000);

    // ===== Pulse scheduling =====
    let pulseStart = -9999;
    let pulseCenter = [0.5, 0.5];
    let cadence = [5, 10]; // seconds (min,max)
    function schedulePulse(){
      const delay = (Math.random()*(cadence[1]-cadence[0]) + cadence[0]) * 1000;
      setTimeout(()=>{
        // randomize center with margin
        const m = 0.08;
        pulseCenter = [m + Math.random()*(1-2*m), m + Math.random()*(1-2*m)];
        pulseStart = performance.now()/1000;
        schedulePulse();
      }, delay);
    }
    schedulePulse();

    // Pause when tab hidden
    let paused = false;
    document.addEventListener('visibilitychange', ()=>{ paused = document.hidden; });

    // Reduced motion?
    const prefersReduce = matchMedia('(prefers-reduced-motion: reduce)');
    let reduce = prefersReduce.matches;
    prefersReduce.addEventListener('change', e=>{ reduce = e.matches; });

    // Render loop
    const t0 = performance.now();
    function frame(nowMS){
      if(!gl) return;
      if(!paused){
        const t = (nowMS - t0)/1000;
        gl.useProgram(program);
        gl.uniform2f(u.res, canvas.width, canvas.height);
        gl.uniform1f(u.time, t);
        gl.uniform1f(u.gridScale, P.gridScale);
        gl.uniform1f(u.lineWidth, P.lineWidth);
        gl.uniform1f(u.baseAmp, reduce ? 0.0 : P.baseAmp);
        gl.uniform1f(u.noiseAmp, reduce ? 0.0 : P.noiseAmp);
        gl.uniform2f(u.pulseCenter, pulseCenter[0], pulseCenter[1]);
        gl.uniform1f(u.pulseStart, reduce ? -9999.0 : pulseStart);
        gl.uniform1f(u.pulseStrength, reduce ? 0.0 : P.pulseStrength);
        gl.uniform1f(u.pulseSpeed, P.pulseSpeed);
        gl.uniform3f(u.lineColor, ...P.lineColor);
        gl.drawArrays(gl.TRIANGLES, 0, 3);
      }
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  </script>
</body>
</html>
